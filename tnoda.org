#+TITLE: Emacs 初期化ファイルの本体
#+STARTUP: content
#+STARTUP: hidestars
#+STARTUP: indent
#+PROPERTY: padline no
#+PROPERTY: results silent
#+TAGS:  key(k) command(c) autoinstall(a) marmalade(m) elget(e) git(g) svn(s) rubikitch(r)

* ユーティリティ
** ディレクトリ構成
*** prefix
#+NAME: tnoda-dotfiles-dir
#+BEGIN_SRC emacs-lisp :tangle no :exports yes
  (eval tnoda/dotfiles-dir)
#+END_SRC

*** elisp\_dir
#+NAME: tnoda-elisp-dir
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval (defconst tnoda/elisp-dir (expand-file-name "elisp" tnoda/dotfiles-dir)))
#+END_SRC

*** info\_dir
#+NAME: tnoda-info-dir
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval (defconst tnoda/info-dir (expand-file-name "share/info" tnoda/dotfiles-dir)))
#+END_SRC

*** src\_dir
#+NAME: tnoda-src-dir
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval (defconst tnoda/src-dir (expand-file-name "src" tnoda/dotfiles-dir)))
#+END_SRC

*** bin\_dir
#+NAME: tnoda-bin-dir
#+BEGIN_SRC emacs-lisp :tangle yes
  (defconst tnoda/bin-dir (expand-file-name "bin" tnoda/dotfiles-dir))
#+END_SRC

*** emacs
#+NAME: emacs-app
#+BEGIN_EXAMPLE
  /Applications/Emacs.app/Contents/MacOS/Emacs
#+END_EXAMPLE

** Mac OS X の Network Location を取得する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/get-current-location ()
    (substring (shell-command-to-string "/usr/sbin/networksetup -getcurrentlocation") 0 -1))
#+END_SRC

** 行間を広くする関数 =tnoda/increase-line-spacing=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/increase-line-spacing ()
    (setq line-spacing 4))
#+END_SRC

* パッケージ管理
** =~/.emacs.d/elisp= とそのサブディレクトリを =load-path= に追加する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (let ((default-directory tnoda/elisp-dir))
    (add-to-list 'load-path default-directory)
    (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

** auto-install.el
*** 初回のインストール（インストーラが実行する）．
#+BEGIN_SRC sh :tangle install-auto-install.sh :var elisp_dir=tnoda-elisp-dir
  curl http://www.emacswiki.org/emacs/download/auto-install.el -o $elisp_dir/auto-install.el
#+END_SRC

*** 二回目からは =auto-install= で自身を更新する．
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "auto-install.el")
#+END_SRC

*** auto-install を =~/.emacs.d/auto-install= で使う．
 
auto-install 先のデフォルトは，=~/.emacs.d/auto-install=
 
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path "~/.emacs.d/auto-install")
  (require 'auto-install)
  (auto-install-compatibility-setup)
#+END_SRC

** Marmalade/ELPA
+ ELPA ではなく Marmalade の package.el をインストールする
  - Marmalade も ELPA 互換なので問題ない．
+ インストール
  #+BEGIN_SRC emacs-lisp :tangle install.el
    (auto-install-from-url "http://repo.or.cz/w/emacs.git/blob_plain/1a0a666f941c99882093d7bd08ced15033bc3f0c:/lisp/emacs-lisp/package.el")
  #+END_SRC
+ 設定
  - Marmalade も使えるようにする
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'package)
    (add-to-list 'package-archives '("ELPA" . "http://tromey.com/elpa/"))
    (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
    (package-initialize)
  #+END_SRC
  
** el-get                                                            :elget:
*** Install
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq el-get-dir "/opt/el-get")
  (add-to-list 'load-path "/opt/el-get/el-get")
  (unless (require 'el-get nil t)
    (url-retrieve
     "https://raw.github.com/dimitri/el-get/master/el-get-install.el"
     (lambda (s)
       (let (el-get-master-branch)
         (goto-char (point-max))
         (eval-print-last-sexp)))))
  (el-get 'sync)
#+END_SRC

* Emacs
** Emacs 起動したらすぐ eshell を使えるようにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook 'eshell)
#+END_SRC

** メール
#+BEGIN_SRC emacs-lisp :tangle yes
  (load "~/.mail.el")
#+END_SRC

** 日本語
+ 日本語で使う
+ UTF-8 で使う

#+BEGIN_SRC emacs-lisp :tangle yes
  (set-language-environment "Japanese")
  (require 'ucs-normalize)
  (prefer-coding-system 'utf-8)
  (setq file-name-coding-system 'utf-8-hfs)
#+END_SRC

** 表示
*** 起動時にウィンドウを擬似最大化する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq initial-frame-alist `((top . 1) (left . 1)
                              (width . 1000) (height . 1000)))
#+END_SRC

*** =s-f= でフォント切り替え．                                            :key:

+ デフォルトは Ricty Ascii + ヒラギノ丸ゴ
+ プログラミング時は Ricty
+ =s-f= で切り替え

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar tnoda/current-fontset 'default)
  
  (defun tnoda/fontset-set-default ()
    (set-fontset-font
     (frame-parameter nil 'font)
     'japanese-jisx0208
     (font-spec :family "Hiragino Maru Gothic ProN" :size 16))
    (setq tnoda/current-fontset 'default))
  
  (defun tnoda/fontset-set-programming ()
    (set-fontset-font
     (frame-parameter nil 'font)
     'japanese-jisx0208
     (font-spec :family "Ricty" :size 16))
    (setq tnoda/current-fontset 'programming))
  
  (defun tnoda/fontset-toggle ()
    (interactive)
    (case tnoda/current-fontset
      ('default
        (tnoda/fontset-set-programming))
      ('programming
       (tnoda/fontset-set-default))
      (t
       (error "invalid fontset"))))
  
  (when window-system
    (set-face-attribute 'default nil
                        :family "Ricty Ascii"
                        :height 160)
    (tnoda/fontset-set-default))
  
  (global-set-key (kbd "s-f") 'tnoda/fontset-toggle)
#+END_SRC

*** 色
#+BEGIN_SRC emacs-lisp :tangle yes
  (when window-system
    (set-foreground-color "gray")
    (set-background-color "#023")
    (set-cursor-color "gray48")
    (set-face-background 'region "blue"))
#+END_SRC

*** ツールバーなどを表示しない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
#+END_SRC

*** 現在行に色をつける．
#+BEGIN_SRC emacs-lisp :tangle yes
  (when window-system
    (global-hl-line-mode 1)
    (set-face-background 'hl-line "black"))
#+END_SRC

*** 起動画面を表示しない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq inhibit-startup-message t)
#+END_SRC

*** =font-lock= を有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-font-lock-mode t)
#+END_SRC

*** 対応する括弧を表示させる．
#+BEGIN_SRC emacs-lisp :tangle yes
  (show-paren-mode 1)
  (set-face-background 'show-paren-match-face "darkgreen")
#+END_SRC．

*** モードラインに時刻を表示させる．
#+BEGIN_SRC emacs-lisp :tangle yes
  (display-time)
#+END_SRC

*** モードラインに行番号・列番号を表示させる．
#+BEGIN_SRC emacs-lisp :tangle yes
  (line-number-mode 1)
  (column-number-mode 1)
#+END_SRC

*** リージョンに色をつける．
#+BEGIN_SRC emacs-lisp :tangle yes
  (transient-mark-mode 1)
#+END_SRC

*** カーソルを点滅させない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (blink-cursor-mode -1)
#+END_SRC

*** Ediff 関連のバッファを一つにまとめる．                        :rubikitch:

きっと auto-install.el で便利．

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

** Mac OS X
*** バッテリー残量を表示する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (display-battery-mode t)
#+END_SRC

*** =browse-url= で Firefox を開く．                              :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "open"
        browse-url-generic-args '("-a" "Firefox"))
#+END_SRC

*** =<M-f1>= で Dictionary.app 起動．                                 :key:

http://sakito.jp/mac/dictionary.html の方法そのまま．

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/dictionary ()
    "dictionary.app"
    (interactive)
    (let ((editable (not buffer-read-only))
          (pt (save-excursion (mouse-set-point last-nonmenu-event)))
          beg end)
      (if (and mark-active
               (<= (region-beginning) pt) (<= pt (region-end)) )
          (setq beg (region-beginning)
                end (region-end))
        (save-excursion
          (goto-char pt)
          (setq end (progn (forward-word) (point)))
          (setq beg (progn (backward-word) (point)))
          ))
      (browse-url
       (concat "dict:///"
               (url-hexify-string (buffer-substring-no-properties beg end))))))
  (global-set-key (kbd "<M-f1>") 'tnoda/dictionary)
#+END_SRC

*** コマンドキーを =meta= キーにする．                                  :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mac-command-modifier 'meta)
#+END_SRC

*** =Opt= キーを =super= キーにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mac-option-modifier 'super)
#+END_SRC

** キーバインド
*** =s-q= を無効に．誤爆したときのダメージが大きすぎる (=save-buffers-kill-emacs=) :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-unset-key (kbd "s-q"))
#+END_SRC

*** =C-h= で =delete-backward-char=.                                    :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key "\C-h" 'delete-backward-char)
#+END_SRC

*** =C-x o= を無効に．                                                :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-unset-key (kbd "C-x o"))
#+END_SRC

*** =C-x C-b= で =ibuffer=.                                             :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key "\C-x\C-b" 'ibuffer)
#+END_SRC

*** =M-/= で =hippie-expand=.                                           :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

*** =C-z= で =eshell=.                                                :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-z") 'eshell)
#+END_SRC

*** =C-x C-c= で =server-edit=. 代わりに =M-x ZZ= で Emacs を終了．     :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-x C-c") 'server-edit)
  (defalias 'ZZ 'save-buffers-kill-emacs)
#+END_SRC

*** =dired-mode= で =W= を押すと =wdired-mode= になる．                 :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key dired-mode-map "W" 'wdired-change-to-wdired-mode)
#+END_SRC

*** =C-;= でウィンドウ切替か水平分割． =C-:= で垂直分割．   :key:rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/other-window-or-split-window-horizontally ()
    (interactive)
    (when (one-window-p) (split-window-horizontally))
    (other-window 1))
  (global-set-key (kbd "C-;") 'tnoda/other-window-or-split-window-horizontally)
  (global-set-key (kbd "C-:") 'split-window-vertically)
#+END_SRC

*** =C-M-;= で =follow-mode=                                :key:rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-M-;") 'follow-delete-other-windows-and-split)
#+END_SRC

*** =<f5>= で =compile= か =executable-interpret=                     :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/script-p ()
      (and (>= (buffer-size) 2)
           (save-restriction
             (widen)
             (string= "#!" (buffer-substring (point-min) (+ 2 (point-min)))))))
  (defun tnoda/compile-or-executable-interpret ()
    (interactive)
    (cond ((tnoda/script-p)
           (call-interactively 'executable-interpret))
          (t
           (call-interactively 'compile))))
  (global-set-key (kbd "<f5>") 'tnoda/compile-or-executable-interpret)
#+END_SRC

*** =C-m= で改行してインデント．                                      :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-m") 'newline-and-indent)
#+END_SRC

*** =C-x 4 q= で =tnoda/View-quit-other-window=.                      :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/View-quit-other-window ()
    (interactive)
    (save-selected-window
      (other-window 1)
      (call-interactively 'View-quit)))
  (define-key ctl-x-4-map (kbd "q") 'tnoda/View-quit-other-window)
#+END_SRC

*** =s-a= で =tnoda/kill-ring-save-whole-buffer=.                     :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/kill-ring-save-whole-buffer ()
    (interactive)
    (save-excursion
      (copy-region-as-kill (point-min) (point-max))))
  (global-set-key (kbd "s-a") 'tnoda/kill-ring-save-whole-buffer)
#+END_SRC

** ログと履歴
*** ログの記録行数を増やす．                                    :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq message-log-max 10000)
#+END_SRC

*** ミニバッファを再帰的に呼び出せるようにする．                :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq enable-recursive-minibuffers t)
#+END_SRC

*** 履歴を沢山保存する．                                        :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq history-length 1000)
#+END_SRC

*** ミニバッファで入力を取り消しても履歴に残す．                :rubikitch:

誤取消で入力が失われるのを防ぐため．

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice abort-recursive-edit (before minibuffer-save activate)
    (when (eq (selected-window) (active-minibuffer-window))
      (add-to-history minibuffer-history-variable (minibuffer-contents))))
#+END_SRC

*** ファイル内のカーソル位置を記憶する．                          :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default save-place t)
  (require 'saveplace)
#+END_SRC

** カレンダー
*** 現在位置を設定する．
+ =calendar-latitude=
+ =calendar-longitude=
+ =calendar-location-name=

#+BEGIN_SRC emacs-lisp :tangle yes
  (load "~/.calendar-location.el")
#+END_SRC

*** 日本の祝日
+ japanese-holidays.el のインストール
  #+BEGIN_SRC emacs-lisp :tangle install.el
    (auto-install-from-url "http://www.meadowy.org/meadow/netinstall/export/799/branches/3.00/pkginfo/japanese-holidays/japanese-holidays.el")
  #+END_SRC
  
+ 設定
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'japanese-holidays)
    (setq calendar-holidays japanese-holidays)
    (setq calendar-mark-holidays-flag t)
    (add-hook 'today-visible-calendar-hook 'calendar-mark-today)
  #+END_SRC

** スクリプトファイルを保存するときには，モードを実行可能に設定する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** =exec-path=
*** =exec-path= に =~/.emacs.d/bin= を追加する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'exec-path tnoda/bin-dir)
#+END_SRC

*** =exec-path= に Homebrew を追加する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'exec-path "/opt/homebrew/bin")
#+END_SRC

*** =exec-path= に =/usr/texbin= を追加する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'exec-path "/usr/texbin")
#+END_SRC

** スペルチェック (ispell/aspell)
+ aspell を使う．
+ 英語日本語混じりの文章でエラーが出ないようなおまじない (ispell-skip-region-alist).

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default ispell-program-name "aspell")
  (eval-after-load "ispell"
    '(add-to-list 'ispell-skip-region-alist '("[^\000-\377]+")))
#+END_SRC

*** =C-M-$= で =ispell-buffer=.                                       :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-M-$") 'ispell-buffer)
#+END_SRC

** GC を減らして軽くする．                                       :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq gc-cons-threshold (* 16 gc-cons-threshold))
#+END_SRC

** yes/no の代わりに y/n.
#+BEGIN_SRC emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)  
#+END_SRC

** 新規ファイルを確認無しに作成する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC

** ダイアログボックスを使わないようにする．                      :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq use-dialog-box nil)
  (defalias 'message-box 'message)
#+END_SRC

** キーストロークをエコーエリアに素早く表示する．                 :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq echo-keystrokes 0.1)
#+END_SRC

** 大きいファイルを開くときの警告を 32 MB 以上にする．             :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq large-file-warning-threshold (* 25 1025 1024))
#+END_SRC

** emacsclient
#+BEGIN_SRC emacs-lisp :tangle yes
  (server-start)
#+END_SRC

** midnight: 深夜に不急と思われるバッファを消す．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'midnight)
#+END_SRC

** =shell-mode= のバッファを消すときに確認しない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq kill-buffer-query-functions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+END_SRC

** インデントにタブを使わない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default indent-tabs-mode nil)
#+END_SRC

** 圧縮ファイルを読み書きできるようにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (auto-compression-mode t)
#+END_SRC

** Narrowing: (=C-x n n=), (=C-x n p=) を有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

** 環境変数 =PATH= を設定する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setenv "PATH" (mapconcat 'identity
                            (list tnoda/bin-dir
                                  (expand-file-name "~/.rbenv/shims")
                                  (expand-file-name "~/Library/Haskell/bin")
                                  "/usr/texbin"
                                  "/opt/homebrew/sbin" "/opt/homebrew/bin"
                                  "/Applications/Emacs.app/Contents/MacOS/bin"
                                  "/Developer/usr/bin" "/Developer/usr/sbin"
                                  "/bin" "/usr/bin" "/usr/X11R6/bin")
                            ":"))
#+END_SRC

** 環境変数 =MANPATH= を設定する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setenv "MANPATH" (mapconcat 'identity
                               (list (expand-file-name "shrea/man" tnoda/dotfiles-dir)
                                     "/opt/homebrew/share/man"
                                     "/Developer/usr/share/man"
                                     "/usr/share/man"
                                     "/usr/X11R6/man")
                               ":"))
#+END_SRC

** =~/.emacs.d/share/info= を優先する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/set-info-dir ()
    (setq Info-directory-list
          (list tnoda/info-dir "/Applications/Emacs.app/Contents/Resources/info")))
  (add-hook 'Info-mode-hook 'tnoda/set-info-dir)
#+END_SRC

** Unified diff を表示する．                                     :rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq diff-switches "-u")
#+END_SRC

** =hi-lock-mode= を有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-hi-lock-mode 1)
#+END_SRC

** =C-x F=, =C-x K=, =C-x V=                                  :key:rubikitch:
#+BEGIN_SRC emacs-lisp :tangle yes
  (find-function-setup-keys)
#+END_SRC

** Conflict したマージファイルを開くときには =smerg-mode= を有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'smerge-mode)
  (defun tnoda/try-smerge ()
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward smerge-begin-re nil t)
        (smerge-mode 1))))
  (add-hook 'find-file-hook 'tnoda/try-smerge)
#+END_SRC

* Global
** minor-mode-hack.el                                :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "minor-mode-hack.el")
#+END_SRC

*** Require
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'minor-mode-hack)
#+END_SRC

** bm.el                                             :autoinstall:rubikitch:
*** インストール
  #+BEGIN_SRC emacs-lisp :tangle install.el
    (auto-install-from-url "http://cvs.savannah.gnu.org/viewvc/*checkout*/bm/bm/bm.el")
  #+END_SRC

*** =bm.el= ロード時にマークを復元する．Emacs を終了してもマークを復元できるようにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq bm-restore-repository-on-load t)
  (load "bm")
  (add-hook 'find-file-hook 'bm-buffer-restore)
  (add-hook 'kill-buffer-hook 'bm-buffer-save)
  (add-hook 'after-save-hook 'bm-buffer-save)
  (add-hook 'after-revert-hook 'bm-buffer-restore)
  (add-hook 'vc-before-checkin-hook 'bm-buffer-save)
#+END_SRC

=bm-restore-repository-on-load= は =bm= ロード前に設定する必要がある．

*** デフォルトではブックマークを永続化しない． =M-x bm-toggle-buffer-persistence= すること．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default bm-buffer-persistence nil)
#+END_SRC

*** マークを湘南色に．
#+BEGIN_SRC emacs-lisp :tangle yes
  (set-face-foreground 'bm-face "darkgreen")
  (set-face-background 'bm-face "darkorange")
#+END_SRC

*** =s-SPC= で現在行をマーク (=bm-toggle=).                             :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "s-SPC") 'bm-toggle)
#+END_SRC

*** =s-<= で前のマーク行に (=bm-previous=).                             :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "s-<") 'bm-previous)
#+END_SRC

*** =s->= で次のマーク行に (=bm-next=).                                 :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "s->") 'bm-next)
#+END_SRC

** sequencial-command.el                             :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-batch "sequential-command")
#+END_SRC
*** =M-a=, =M-e=, =M-u=, =M-d=, =M-c= の挙動が変わり，連打が有効になる．        :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'sequential-command-config)
  (sequential-command-setup-keys)
#+END_SRC

** key-chord.el                                      :autoinstall:rubikitch:

キーボード同時押し時のコマンドを指定する =key-chord-define= が使えるようになる．

*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "key-chord.el")
#+END_SRC

*** 全てのバッファで =key-chord-mode= を有効に．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'key-chord)
  (key-chord-mode 1)
#+END_SRC

*** 同時押し判定は 0.3 秒以内．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq key-chord-two-keys-delay 0.03)
#+END_SRC

** redo+.el                                          :autoinstall:rubikitch:

=redo.el= を使うとバッファが壊れるので注意する．

*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "redo+.el")
#+END_SRC

*** 過去の undo が redo されないようにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'redo+)
  (setq undo-no-redo t)
#+END_SRC

*** 大量の undo に耐えられるようにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq undo-limit 600000)
  (setq undo-strong-limit 900000)
#+END_SRC

*** =C-?= で =redo=.                                                  :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-?") 'redo)
#+END_SRC

** uniquify.el                                                   :rubikitch:

ファイル名が同じファイルを複数開いたときに，
バッファ名にディレクトリ名を含めて区別しやすくする．

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
  (setq uniquify-ignore-buffers-re "*[^*]+*")
#+END_SRC名

** ido.el
#+BEGIN_SRC emacs-lisp :tangle yes
  (ido-mode 1)
  (ido-everywhere 1)
  (setq ido-slow-ftp-hosts '("ssh"))
  (setq ido-create-new-buffer 'always)
  (setq ido-file-extensions-order '(".org" ".rb"))
  (setq ido-enable-flex-matching t)
#+END_SRC

*** =C-x C-f= で URL を開く (ido-use-url-at-pint).
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ido-use-url-at-point t)
#+END_SRC

** recentf-ext.el                                    :autoinstall:rubikitch:

最近使ったファイルを表示する =recentf.el= をもっと便利に．

*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "recentf-ext.el")
#+END_SRC

*** =recentf-exclude= に履歴に含めないファイルを設定．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'recentf-ext)
  (setq recentf-max-saved-items 3000)
  (setq recentf-exclude '("/TAGS$" "/tmp/$" "\.html$" "/work/$" "/\.emacs\.bmk$" "~$"))
  (setq tnoda/recentf-exclude-org 
        (list
         "org_archive$"
         "/mobileorg.org$"
         "/COMMIT_EDITMSG$"
         (expand-file-name "~/diary")
         (expand-file-name "~/org/main\.org")
         (expand-file-name "~/org/notes\.org")))
  (setq recentf-exclude (append recentf-exclude tnoda/recentf-exclude-org))
#+END_SRC

*** =recentf= でディレクトリを扱わない．

=recentf-ext.el= が

#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'dired-mode-hook 'recentf-add-dired-directory)
#+END_SRC

しているので， =remove-hook= する．

#+BEGIN_SRC emacs-lisp :tangle yes
  (remove-hook 'dired-mode-hook 'recentf-add-dired-directory)
#+END_SRC

*** =C-@= で =recentf-open-files=                                     :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-@") 'recentf-open-files)
#+END_SRC

** bookmark.el                                                   :rubikitch:
ファイル内の特定位置をマークする．
+ ブックマークに変更があれば即保存 (bookmark-save-flag).
+ 最近使ったブックマークを燁に持ってくる (tnoda/bookmark-arrange).

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq bookmark-save-flag 1)
  (setq bookmark-sort-flag nil)
  (defun tnoda/bookmark-arrange ()
    (let ((latest (bookmark-get-bookmark bookmark)))
      (setq bookmark-alist (cons latest (delq latest bookmark-alist))))
    (bookmark-save))
  (add-hook 'bookmark-after-jump-hook 'tnoda/bookmark-arrange)
#+END_SRC

** auto-save-buffers.el                              :autoinstall:rubikitch:
+ インストール
  #+BEGIN_SRC emacs-lisp :tangle install.el
    (auto-install-from-url "http://homepage3.nifty.com/oatu/emacs/archives/auto-save-buffers.el")
  #+END_SRC

+ 2 秒何もしなければセーブ
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'auto-save-buffers)
    (run-with-idle-timer 2 t 'auto-save-buffers)
  #+END_SRC

** sense-region.el                               :key:autoinstall:rubikitch:

=C-SPC= 連打で選択範囲が広がっていく．マークとポイントが対角線の矩形を選択できる．

*** インストール
  #+BEGIN_SRC emacs-lisp :tangle install.el
    (auto-install-from-url "https://raw.github.com/gist/1776988/63a04b9b81bc5dbeef2d3878994639fd81ddc276/sense-region.el")
  #+END_SRC

*** すべてのバッファで sence-region を有効に．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'sense-region)
  (sense-region-on)
#+END_SRC

*** =C-SPC= 連打で =mark-word= できるので，=M-@= を無効にする．あまり使わないし．
- Note taken on [2012-01-18 Wed 10:21] \\
  =M-@= は特等席すぎるので，他で使うことにする．anything にしようかな．．．
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-unset-key (kbd "M-@"))
#+END_SRC

** cycle-buffers.el                                  :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "cycle-buffer.el")
#+END_SRC

*** =autoload= ではなく =require= する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'cycle-buffer)
#+END_SRC

*** Mew の summary mode を対象外にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'cycle-buffer-filter
               '(not (string-match "^\\+.+" (buffer-name))))
#+END_SRC

*** gtd 関連ファイルを対象外にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'cycle-buffer-filter
               '(not (member (buffer-name) '("main.org" "notes.org" "diary"))))
#+END_SRC

*** Org の archive ファイルを対象外にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'cycle-buffer-filter
               '(not (string-match "_archive$" (buffer-name))))
#+END_SRC

*** =M-<= で前のバッファに移動 (=cycle-buffer-backward=).               :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-<")   'cycle-buffer-backward)
#+END_SRC

*** =M->= で次のバッファに移動 (=cycle-buffer=).                        :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M->")   'cycle-buffer)
#+END_SRC

** popwin.el                                                   :autoinstall:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-url "https://raw.github.com/m2ym/popwin-el/v0.3/popwin.el")
#+END_SRC

*** =special-display-function= で使う．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'popwin)
  (setq special-display-function 'popwin:special-display-popup-window)
#+END_SRC

*** emacsclient で編集するバッファを =tnoda/server-window= で表示．

Eshell から =emacsclient= したときに，違うフレームで表示したい．

+ popwin できるバッファなら =popwin:display-buffer= で表示．
+ popwin できないバッファなら =pop-to-buffer= で表示．
  - これでも， =server-edit= 後にポイントが別フレームに行ったままになる
    ので =C-;= で戻らないといけなくて，ちょっとだけ面倒．

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/server-window (buf)
    (if (some (lambda (x)
                (equal (buffer-name buf) (car x)))
              popwin:special-display-config)
        (popwin:display-buffer buf)
      (pop-to-buffer buf)))
  (setq server-window 'tnoda/server-window)
#+END_SRC

*** Git の =git-rebase-todo= を上に表示する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (push '("git-rebase-todo" :position top) popwin:special-display-config)
#+END_SRC

** yasnippet.el                                                        :git:
*** github のリポジトリを submodule にして使う．

https://github.com/capitaomorte/yasnippet

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path (expand-file-name "plugins/yasnippet" tnoda/dotfiles-dir))
  (require 'yasnippet)
  (yas/global-mode 1)
#+END_SRC

*** メジャーモードが =TAB= キーをインデントに使っているときの回避策．

http://capitaomorte.github.com/yasnippet/faq.html

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun yas/advise-indent-function (function-symbol)
    (eval `(defadvice ,function-symbol (around yas/try-expand-first activate)
             ,(format
               "Try to expand a snippet before point, then call `%s' as usual"
               function-symbol)
             (let ((yas/fallback-behavior nil))
               (unless (and (interactive-p)
                            (yas/expand))
                 ad-do-it)))))
#+END_SRC

この =yas/advice-indent-function= は，

#+BEGIN_EXAMPLE
  (yas/advise-indent-function 'ruby-indent-line)
#+END_EXAMPLE

のように使う．

*** スニペット用のヘルパー関数を定義．
**** =tnoda/classify=. ActiveSupport の =String#classify= と同等．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/classify (str)
    "Return rails-classified string."
    (replace-regexp-in-string "_" "" (capitalize str)))
#+END_SRC

**** =tnoda/guess-ruby-class-name=. ファイル名から Ruby のクラス名を推測する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/guess-ruby-class-name ()
    "Return the Ruby class name associating with the current buffer."
    (tnoda/classify (file-name-sans-extension
                     (file-name-nondirectory
                      (or (buffer-file-name)
                          (buffer-name (current-buffer)))))))
#+END_SRC

** point-undo.el                                     :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "point-undo.el")
#+END_SRC

*** Require
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'point-undo)
#+END_SRC

*** =C-,== でカーソルをコマンド実行前の位置に戻す (=point-undo=)        :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-,") 'point-undo)
#+END_SRC

*** =C-.= でカーソルを次のコマンド実行位置に進める (=point-redo=)       :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-.") 'point-redo)
#+END_SRC

** goto-chg.el                                       :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "goto-chg.el")
#+END_SRC

*** Require
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'goto-chg)
#+END_SRC

*** =C-<= でカーソルを最後の編集場所に戻す (=goto-last-change=).            :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-<") 'goto-last-change)
#+END_SRC

*** =C->= でカーソルを次の編集場所に進める (=goto-last-change-reverse=). :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C->") 'goto-last-change-reverse)
#+END_SRC

** eldoc-extension.el                                          :autoinstall:
+ インストール
  #+BEGIN_SRC emacs-lisp :tangle install.el
    (auto-install-from-emacswiki "eldoc-extension.el")
  #+END_SRC
+ 設定
  - =emacs-lisp-mode= と =ielm-mode= で有効にする．
  - =lisp-interaction-mode= は Clojure にとっておく．
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'eldoc)
    (require 'eldoc-extension)
    (setq eldoc-idle-delay 0.1)
    (setq eldoc-echo-area-use-multiline-p t)
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
  #+END_SRC

** tempbuf.el                                        :autoinstall:rubikitch:
+ =tempbuf.el= は =tempbuf-mode= マイナーモードを提供する．
  + =tempbuf-mode= はバッファごとに作用し，不要と思われるバッファを自動削除．
+ インストール
  #+BEGIN_SRC emacs-lisp :tangle install.el
    (auto-install-from-emacswiki "tempbuf.el")
  #+END_SRC
+ 設定
  - =dired-mode= でだけ =tempbuf-mode= を有効にする．
    #+BEGIN_SRC emacs-lisp :tangle yes
      (require 'tempbuf)
      (add-hook 'dired-mode-hook 'turn-on-tempbuf-mode)
    #+END_SRC
    
** auto-complete.el                                        :elget:rubikitch:
*** Install via el-get.
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync 'auto-complete)
  (require 'auto-complete-config)
  (ac-config-default)
#+END_SRC

*** ac-slime
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync '(ac-slime))
  (require 'ac-slime)
  (add-hook 'slime-mode-hook 'set-up-slime-ac)
  (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
  (add-to-list 'ac-modes 'slime-repl-mode)
#+END_SRC

*** 4 文字以上にならないと補完を開始しない (=ac-auto-start=).
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ac-auto-start 4)
#+END_SRC
  
** col-highlight.el                                  :autoinstall:rubikitch:

現在桁をハイライトする．

*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-batch "col-highlight")
#+END_SRC

*** =M-x column-highlight-mode= で桁ハイライト切替．              :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'col-highlight)
#+END_SRC

** paredit.el                                                  :autoinstall:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-url "http://mumble.net/~campbell/emacs/paredit.el")
#+END_SRC

*** LISP 関係のモードで有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'paredit)
  (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook 'enable-paredit-mode)
  (add-hook 'lisp-mode-hook 'enable-paredit-mode)
  (add-hook 'ielm-mode-hook 'enable-paredit-mode)
#+END_SRC

** rainbow-delimiters.el                                       :autoinstall:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "rainbow-delimiters.el")
#+END_SRC

*** とりあえず =emacs-lisp-mode= と =ielm=mode= で有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'rainbow-delimiters)
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'ielm-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

** open-junk-file.el                                 :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "open-junk-file.el")
#+END_SRC

*** =~/.junk/= に保存，ファイル名は =%Y%m%d-%H%M%S."．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'open-junk-file)
  (setq open-junk-file-format "~/.junk/%Y%m%d-%H%M%S.")
#+END_SRC

*** =C-x f= で =open-junk-file=. =set-fill-column= は使わない．                     :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-x f") 'open-junk-file)
#+END_SRC

** lispxmp.el                                        :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "lispxmp.el")
#+END_SRC

*** =<S-f5>= で =lispxmp=.                                            :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'lispxmp)
  (global-set-key (kbd "<S-f5>") 'lispxmp)
#+END_SRC

** color-moccur.el                                   :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "color-moccur.el")
  (auto-install-from-emacswiki "moccur-edit.el")
#+END_SRC

*** スペースで区切られた複数の単語にマッチする
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'moccur-edit)
  (setq moccur-split-edit t)
#+END_SRC

*** =M-s o= を =occur-by-moccur= に置き換える．                       :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-s o") 'occur-by-moccur)
#+END_SRC

*** =M-s O= に =moccur= を割り当てる．                                :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-s O") 'moccur)
#+END_SRC

** text-adjust.el                                    :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-url "http://taiyaki.org/elisp/mell/src/mell.el")
  (auto-install-from-url "http://taiyaki.org/elisp/text-adjust/src/text-adjust.el")
#+END_SRC
*** =kinsoku-ascii= がいつのまにか =kinsoku.el= から無くなっているので定義．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'text-adjust)
  (defvar kinsoku-ascii t "Do kinsoku-shori for ASCII.")
#+END_SRC

*** =M-q= で =text-adjust-*= する．=C-u M-q= で =*-buffer=. =C-u C-u M-q= で =fill= だけ． :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/text-adjust (arg)
    (interactive "p")
    (case arg
      (16
       (call-interactively 'text-adjust-fill))
      (4
       (call-interactively 'text-adjust-codecheck-buffer)
       (call-interactively 'text-adjust-hankaku-buffer)
       (call-interactively 'text-adjust-space-buffer)
       (call-interactively 'text-adjust-fill-buffer))
      (t
       (call-interactively 'text-adjust-codecheck)
       (call-interactively 'text-adjust-hankaku)
       (call-interactively 'text-adjust-space)
       (call-interactively 'text-adjust-fill))))
  (global-set-key (kbd "M-q") 'tnoda/text-adjust)
#+END_SRC

*** 左マージンを考慮する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq adaptive-fill-regexp "[ \t]*")
  (setq adaptive-fill-mode t)
#+END_SRC

*** ？と！とを半角へ変換しないようにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq text-adjust-hankaku-except "？！＠ー〜、，。．")
#+END_SRC

** igrep.el                                          :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "igrep.el")
#+END_SRC
*** =M-x igrep= で =grep= コマンドラインを対話的に編集．
+ 正規表現のデフォルトは現在位置の単語．
+ ファイルは現在のバッファと拡張子が同じもの．

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'igrep)
#+END_SRC

** grep-a-lot.el                                     :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "grep-a-lot.el")
#+END_SRC

*** =*grep*= バッファを複数もつことができる．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'grep-a-lot)
#+END_SRC

*** =igrep.el= でも grep-a-lot する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (grep-a-lot-advise igrep)
#+END_SRC

*** =M-g =/]/[/-/_= で =*grep*= バッファ操作．                        :key:
+ =M-g == ... 最後の grep バッファを開く．
+ =M-g ]= ... 次の grep バッファを開く．
+ =M-g [= ... 前の grep バッファを開く．
+ =M-g -= ... 最後の grep バッファを削除する．
+ =M-g _= ... すべての grep バッファを削除する．

#+BEGIN_SRC emacs-lisp :tangle yes
  (grep-a-lot-setup-keys)
#+END_SRC

** grep-edit.el                                      :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "grep-edit.el")
#+END_SRC

*** Require
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'grep-edit)
#+END_SRC
*** =*grep*= で =C-c C-e= すると変更を反映．                          :key:
*** =*grep*= で =C-c C-r= するとリージョンの変更を破棄．              :key:
*** =*grep*= で =C-c C-u= するとバッファへの変更を破棄．              :key:

** shell-history.el                                  :autoinstall:rubikitch:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-emacswiki "shell-history.el")
#+END_SRC

*** =M-x shell-add-to-history= を使えるようにする．               :command:

このコマンドは，シェルコマンドを実行せずに履歴に追加する．
rubikitch 先生曰く「コマンドの『カラ実行』」．

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'shell-history)
#+END_SRC

** hideshow-org.el                                             :autoinstall:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-url "https://raw.github.com/secelis/hideshow-org/master/hideshow-org.el")
#+END_SRC

*** =tnoda/hs-org/minor-mode-activate=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'hideshow-org)
  (defun tnoda/hs-org/minor-mode-activate ()
    "Activate hideshow-org"
    (interactive)
    (hs-org/minor-mode 1)
    (raise-minor-mode-map-alist 'hs-org/minor-mode))
#+END_SRC

*** 折りたたみ部分をハイライトする =tnoda/highlight-overlay=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/highlight-overlay (ov)
    "Self-explanatory!"
    (overlay-put ov 'display (propertize (format "...") 'face 'highlight)))
  
  (setq hs-set-up-overlay 'tnoda/highlight-overlay)
#+END_SRC

* Eshell
** Plan 9 Smart Shell
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'eshell)
  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)
#+END_SRC

** プロンプトの色を変える．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'em-prompt)
  (set-face-foreground 'eshell-prompt "cyan")
#+END_SRC

** プロンプトに Git のブランチ名を表示．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'vc-git)
  (defun tnoda/eshell-git-branch ()
    "Return the branch name surrounded by square brackets, 
  or nil if the current directory is not in a Git repsitory."
    (let ((branch (vc-git-working-revision (eshell/pwd))))
      (when (< 0 (length branch))
        (format "[%s]" branch))))
  
  (defun tnoda/eshell-prompt-function ()
    (mapconcat 'identity
               (delq nil (list
                          (abbreviate-file-name (eshell/pwd))
                          (tnoda/eshell-git-branch)
                          (if (= 0 (user-uid))
                              "# "
                            "$ ")))
               " "))
  
  (setq eshell-prompt-function 'tnoda/eshell-prompt-function)
#+END_SRC

* Pcomplete
** Git ブランチのリストを返す関数 =tnoda/git-branches=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/git-branches ()
      (split-string (shell-command-to-string "git branch | sed -e 's/[ *]*//'")))
#+END_SRC

** Git でステータス変更があったファイルのリストを返す関数 =tnoda/git-modified-files=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/git-modified-files ()
      (split-string (shell-command-to-string "git status -s | sed -e 's/^.. *//'")))
#+END_SRC

** =m= (=git merge= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun pcomplete/m ()
    "Completion for `m' (`git merge')"
    (pcomplete-here* (tnoda/git-branches)))
#+END_SRC

** =co= (=git checkout= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun pcomplete/co ()
    "Completion for `co' (`git checkout')"
    (pcomplete-here* (tnoda/git-branches)))
#+END_SRC

** =bd= (=git branch -d= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun pcomplete/bd ()
    "Completion for `bd' (`git branch -d')"
    (pcomplete-here* (tnoda/git-branches)))
#+END_SRC

** =a= (=git add -p= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun pcomplete/a ()
    "Completion for `a' (`git add -p')"
    (while (pcomplete-here (tnoda/git-modified-files))))
#+END_SRC

** =git add= と =git rm= とをを補完する．

=git add= は新規ファイルの追加にのみ使用する．既存ファイルのステージングは =a=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/git-untracked-files ()
    (split-string (shell-command-to-string "git status -s -u | sed -e 's/^...//'")))
  
  (defconst pcmpl-git-commands
    '("add" "bisect" "branch" "checkout" "clone"
      "commit" "diff" "fetch" "grep"
      "init" "log" "merge" "mv" "pull" "push" "rebase"
      "reset" "rm" "show" "status" "tag" )
    "List of `git' commands")
  
  (defun pcomplete/git ()
    "Completion for `git'"
    ;; Completion for the command argument.
    (pcomplete-here* pcmpl-git-commands)  
    ;; complete files/dirs forever if the command is `add' or `rm'
    (cond
     ((pcomplete-match (regexp-opt '("add") ))
      (while (pcomplete-here (tnoda/git-untracked-files))))
     ((pcomplete-match (regexp-opt '("rm" "reset" "mv")) 1)
      (while (pcomplete-here (pcomplete-entries))))))
#+END_SRC

** =d= (=git diff= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/git-unstaged-files ()
    "Return a list of files which are modified but unstaged."
    (split-string (shell-command-to-string "git status -s | egrep '^.M' | sed -e 's/^.M //'")))
  
  (defun pcomplete/d ()
    "Completion for `d' (`git diff')."
    (while (pcomplete-here (tnoda/git-unstaged-files))))
#+END_SRC

** =dc= (=git diff --cached= へのエイリアス) を補完する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/git-staged-files ()
    "Return a list of staged files."
    (split-string (shell-command-to-string "git status -s | egrep '^M' | sed -e 's/^M.//'")))
  
  (defun pcomplete/dc ()
    "Completion for `dc' (`git diff')."
    (while (pcomplete-here (tnoda/git-staged-files))))
#+END_SRC

* Org Mode                                                              :git:

本家ではなく，[[http://repo.or.cz/w/org-mode.git][repo.or.cz の mirror]] を Git のサブモジュールにしている．
Git プロトコルではなく HTTP を使うため．

** =src/org= を変更したら =update-org.sh= を実行する．

=src/org/lisp/org-install.el= と info ファイルとを作り直す．

#+BEGIN_SRC sh :tangle update-org.sh :var src_dir=tnoda-src-dir prefix=tnoda-dotfiles-dir emacs=emacs-app
  cd $src_dir/org
  make EMACS=$emacs lisp/org-install.el
  make EMACS=$emacs compile
  make EMACS=$emacs prefix=$prefix install-info
#+END_SRC

** Common
*** Require
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'org-install)
  (require 'org-habit)
#+END_SRC

*** =~/org= で Org を使う．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-directory "~/org")
#+END_SRC

*** =org-extend-today-until=
My day really ends at two o'clock in the morning.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-extend-today-until 2)
#+END_SRC

*** =C-,== と =C-'== に割り当てられる =org-cycle-agenda-files= を無効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (rassq-delete-all 'org-cycle-agenda-files org-mode-map)
#+END_SRC

*** =org-edit-special= 中は auto-save-buffers を停止する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (lexical-let ((previous-active-p))
    (defadvice org-edit-src-code (before tnoda/auto-save-buffers-toggle activate)
      "Disable auto-save-buffers."
      (setq previous-active-p  auto-save-buffers-active-p)
      (setq auto-save-buffers-active-p nil))
    (defadvice org-edit-src-exit (after tndoa/auto-save-buffers-toggle activate)
      "Recover auto-save-buffers."
      (setq auto-save-buffers-active-p previous-active-p)))
#+END_SRC

停止しないと，src ブロックを編集している最中に，

#+BEGIN_QUOTE
foo.org has changed since visited or saved.  Save anyway? (y or n) !
foo.org changed on disk; really edit the buffer? (y, n, r or C-h) 
File on disk now will become a backup file if you save these changes.
#+END_QUOTE

と怒られる．

*** ~=code=~ の face を org-code から =font-lock-constant-face= に変更する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-emphasis-alist
        (cons '("=" font-lock-constant-face "<code>" "</code>" verbatim)
              (remove-if (lambda (x)
                           (equal "=" (car x)))
                         org-emphasis-alist)))
#+END_SRC
** 見出し入力の改善．
*** =C-M-RET= で =org-insert-substring=                                 :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key org-mode-map (kbd "<C-M-return>") 'org-insert-subheading)
#+END_SRC

*** =C-u C-RET= で一レベル下の見出し， =C-u C-u C-RET= で一レベル上の見出し． :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/org-insert-heading-respect-content (arg)
    (interactive "p")
    (org-insert-heading-respect-content)
    (case arg
      (4 (org-do-demote))
      (16 (org-do-promote))))
  
  (define-key org-mode-map (kbd "<C-return>") 'tnoda/org-insert-heading-respect-content)
#+END_SRC

** Link
*** =C-c l= で org-store-link.                                          :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-c l") 'org-store-link)
#+END_SRC

** Refile
main.org のトップレベルに refile できるようにする．

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-refile-targets
        '(("main.org" . (:level . 1))))
#+END_SRC

** To-Do
*** =TODO= キーワードは各ファイルで共通のものを使うことにする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-todo-keywords
        '((sequence "TODO(t)" "STARTED(s)" "WAITING(w@/!)" "APPT(a)" "|"
                    "DONE(d!)" "CANCELLED(c@)" "DEFERRED(f@)" "DELEGATED(g@/!)")))
#+END_SRC

*** =TODO= ステータスが =STARTED= に変化したらクロックを開始する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun sacha/org-clock-in-if-starting ()
    "Clock in when the task is marked STARTED."
    (when (and (string= state "STARTED")
               (not (string= last-state state)))
      (org-clock-in)))
  (add-hook 'org-after-todo-state-change-hook
            'sacha/org-clock-in-if-starting)
  ;; (defadvice org-clock-in (after sacha activate)
  ;;   "Set this task's status to 'STARTED'."
  ;;   (org-todo "STARTED"))
  (defun sacha/org-clock-out-if-waiting ()
    "Clock in when the task is marked STARTED."
    (when (and (string= state "WAITING")
               (not (string= last-state state)))
      (org-clock-out)))
  (add-hook 'org-after-todo-state-change-hook
            'sacha/org-clock-out-if-waiting)
#+END_SRC

** Capture
+ ノートファイルには notes.org だけを使う．Capture は常にこのファイルに保存．
+ テンプレートは 2 種類だけ
  - Note
    - 基本的にはこれを使う
    - カレントタスクのクロックは止めない (:clock-keep)
    - notes.org を開いていなければ，notes.org バッファを残さない (:kill-buffer)
  - Away
    - 席を離れるとき
    - カレントタスクのクロックを停止 (:clock-in)
    - Capture 終了時に元タスクのクロックを再開 (:clock-resume)
    - notes.org を開いていなければ，notes.org バッファを残さない (:kill-buffer)
   
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-default-notes-file (expand-file-name "notes.org" org-directory))
  (setq org-reverse-note-order t)
  (setq org-capture-templates
        '(("n" "Note" entry (file "") "* %?\n  %U\n  %i\n  %a"
           :clock-keep t
           :kill-buffer t)
          ("a" "Away" entry (file "") "* %? :away:"
           :clock-in t
           :clock-resume t
           :kill-buffer t)
          ("t" "Task" entry (file+headline tnoda/gtd-file "Tasks")
           "* TODO %?\n %i\n %a"
           :clock-keep t
           :kill-buffer t)))
#+END_SRC

*** =C-c n= で Capture Note 開始．                                      :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/org-capture-note ()
      (interactive)
      (org-capture nil "n"))
    (global-set-key (kbd "C-c n") 'tnoda/org-capture-note)
#+END_SRC

*** =C-c z= で Capture Away 開始．                                      :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/org-capture-away ()
    (interactive)
    (org-capture nil "a"))
  (global-set-key (kbd "C-c z") 'tnoda/org-capture-away)
#+END_SRC

*** =C-c t= で Capture Task 開始．                                      :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/org-capture-task ()
    (interactive)
    (org-capture nil "t"))
  (global-set-key (kbd "C-c t") 'tnoda/org-capture-task)
#+END_SRC

** GTD
*** =M-x gtd= で =main.org= を開く．                              :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defconst tnoda/gtd-file (expand-file-name "main.org" org-directory))
    (defun gtd ()
      (interactive)
      (find-file tnoda/gtd-file))
#+END_SRC

*** =M-x notes= で =notes.org= を開く．                           :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun notes ()
    (interactive)
    (find-file org-default-notes-file))
#+END_SRC
  
*** =M-x flagged= で =flagged.org= を開く．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun flagged ()
    (interactive)
    (find-file (expand-file-name "flagged.org" org-directory)))
#+END_SRC

*** =C-c g= で =org-clock-goto=.                                        :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-c g") 'org-clock-goto)
#+END_SRC

** Agenda
*** Agenda に含めるファイルは， =main.org= と =notes.org=  の 2つ．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-files (list tnoda/gtd-file org-default-notes-file))
#+END_SRC

*** =<S-f7>= と =<f7>= に Org Agenda を開くコマンドを割り当てる．     :key:
- 一日の始まり→ =<S-f7>= ... Home Lists
- タスクの確認→ =<f7>= ... Daily Action List
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-custom-commands
        '(("H" "Home Lists"
           ((agenda "")
            (tags-todo "@home")
            (tags-todo "@univ")
            (tags-todo "errands")
            (tags-todo "emacs")))
          ("D" "Daily Action List"
           ((agenda "" ((org-agenda-ndays 1)
                        (org-agenda-sorting-strategy
                         (quote ((agenda time-up priority-down tag-up) )))
                        (org-deadline-warning-days 0)))))))
  (defun tnoda/org-agenda-home-lists ()
    (interactive)
    (org-agenda nil "H"))
  (global-set-key (kbd "<S-f7>") 'tnoda/org-agenda-home-lists)
  (defun tnoda/org-agenda-daily-action-list ()
    (interactive)
    (org-agenda nil "D"))
  (global-set-key (kbd "<f7>") 'tnoda/org-agenda-daily-action-list)
#+END_SRC

*** そのほかの設定
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-include-diary t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-start-on-weekday nil)
#+END_SRC

** Mobile
*** DropBox を利用する．
+ DropBox を利用して，MobileOrg と sync する (org-mobile-directory).
+ MobileOrg の Capture は flagged.org に (org-mobile-index-for-pull).

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-mobile-inbox-for-pull "~/org/flagged.org")
  (setq org-mobile-directory "~/Dropbox/MobileOrg")
#+END_SRC

*** 暗号化する．パスワードは別ファイルに保存．
+ 暗号化する (org-mobile-use-encryption).
  - パスワードを設定 (org-mobile-encryption-password).

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-mobile-use-encryption t)
  (load "~/.org-mobile-encryption-password.el")
#+END_SRC

** Babel
*** ob-markdown のインストール．
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-url "https://raw.github.com/tnoda/ob-markdown/master/ob-markdown.el")
#+END_SRC

*** Emacs Lisp 以外の言語も有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (R . t)
     (clojure . t)
     (ditaa . t)
     (dot . t)
     (haskell . t)
     (java . t)
     (js . t)
     (latex . t)
     (org . t)
     (ruby . t)
     (sh . t)
     (markdown . t)
     (latex . t)))
#+END_SRC

*** コードブロックのフォント修飾は，Emacs が重くなるのでやめる．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-src-fontify-natively nil)
#+END_SRC

*** コードブロックを確認無しに実行する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

** Beamer
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-export-latex-date-format "%Y-%m-%d")
  (setq org-export-latex-classes nil)
  (add-to-list 'org-export-latex-classes
    '("jsarticle"
      "\\documentclass[a4j]{jsarticle}"
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
      ("\\paragraph{%s}" . "\\paragraph*{%s}")
      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
  ))
  (add-to-list 'org-export-latex-classes
    '("beamer"
      "\\documentclass[compress,dvipdfm]{beamer}"
      org-beamer-sectioning
  ))
#+END_SRC
** =el= 同時押しで emacs-lisp の src ブロック挿入．                       :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/org-babel-demarcate-block-as-elisp ()
    (interactive)
    (insert "#+BEGIN_SRC emacs-lisp :tangle yes\n\n#+END_SRC")
    (org-indent-line-function)
    (org-edit-special))
  (key-chord-define org-mode-map "el" 'tnoda/org-babel-demarcate-block-as-elisp)
#+END_SRC

** =dm= 同時押しで markdown の src ブロック挿入．                      :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/org-babel-demarcate-block-as-markdown ()
    (interactive)
    (insert "#+BEGIN_SRC markdown :tangle yes\n\n#+END_SRC")
    (org-indent-line-function)
    (org-edit-special))
  (key-chord-define org-mode-map "dm" 'tnoda/org-babel-demarcate-block-as-markdown)
#+END_SRC

** Easy Templates
+ =<s= で =#+STARTUP: =
+ =<S= で =#+SETUPFILE: =
+ =<p= で =#+PROPERTY: =

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-structure-template-alist
        (remove-if #'(lambda (x) (member (car x) '("s" "S" "p")))
                   org-structure-template-alist))
  (push '("s" "#+STARTUP: ") org-structure-template-alist)
  (push '("S" "#+SETUPFILE: %file ?") org-structure-template-alist)
  (push '("p" "#+PROPERTY: ") org-structure-template-alist)
#+END_SRC

* SKK
** インストール
#+BEGIN_SRC sh :tangle install-skk.sh :var prefix=tnoda-dotfiles-dir elisp_dir=tnoda-elisp-dir info_dir=tnoda-info-dir emacs=emacs-app
  cd src
  curl http://www.ring.gr.jp/archives/elisp/skk/maintrunk/ddskk-14.4.tar.gz | tar zxf -
  cd ddskk-14.4
  echo "(setq PREFIX \"${prefix}\")
  (setq SKK_DATADIR \"${prefix}/share/skk\")
  (setq SKK_INFODIR \"${info_dir}\")
  (setq SKK_LISPDIR \"${elisp_dir}/skk\")
  (setq SKK_SET_JISYO t)" > SKK-CFG
  make EMACS=$emacs install
#+END_SRC

** =C-x C-j= で =skk-mode=.                                             :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'skk-autoloads)
  (define-key ctl-x-map (kbd "C-j") 'skk-mode)
#+END_SRC

** =C-\= でも =skk-mode=.                                              :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-\\") 'skk-mode)
#+END_SRC

** =skk-mode= なバッファで =isearch= するときにはミニバッファでも SKK.

=(require 'skk-setup)= すると，=C-x j= と =C-x t= にそれぞれ
=skk-auto-fill=mode= と =skk-tutorial= が割り当てられるので，
=skk-setup.el= は使わないことにする．代わりに =skk-setup.el=
で定義されている関数をコピペする．

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun skk-isearch-setup-maybe ()
    (require 'skk-vars)
    (when (or (eq skk-isearch-mode-enable 'always)
              (and (boundp 'skk-mode)
                   skk-mode
                   skk-isearch-mode-enable))
      (skk-isearch-mode-setup)))
  
  (defun skk-isearch-cleanup-maybe ()
    (require 'skk-vars)
    (when (and (featurep 'skk-isearch)
               skk-isearch-mode-enable)
      (skk-isearch-mode-cleanup)))
  
  (add-hook 'isearch-mode-hook #'skk-isearch-setup-maybe)
  (add-hook 'isearch-mode-end-hook #'skk-isearch-cleanup-maybe)
#+END_SRC

** =~/.skk.el= の設定
+ =skk-large-jisyo=
+ =skk-server-host=
+ =skk-server-portnum=
+ =skk-today= / =skk-clock= で西暦表示 (=skk-data-ad=).
+ 読点句点の代わりに，「，」「．」を使う (=skk-rom-kana-rule-list=).
+ アノテーションを表示する (=skk-show-annotation=).
+ 見出し語と送り仮名が一致した候補を優先表示 (=skk-henkan-strict-okuri-precedence=).
+ 半角カナの入力規則を有効に (=skk-use-jisx0201-input-method=).

* Migemo

+ cmigemo を https://gist.github.com/1824249 の formula で =brew install= する．
+ migemo.el のインストールと設定は，http://d.hatena.ne.jp/samurai20000/20100907/1283791433 を参考にする．

** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-url "https://raw.github.com/gist/457761/539882a79ec11bc9b6e1ac417cdafe0e198e245f/migemo.el")
#+END_SRC

** C/Migemo を使う．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'migemo)
  (setq migemo-command "cmigemo")
  (setq migemo-options '("-q" "--emacs"))
  (setq migemo-dictionary "/opt/homebrew/Cellar/cmigemo/20110227/share/migemo/utf-8/migemo-dict")
  (setq migemo-user-dictionary nil)
  (setq migemo-regex-dictionary nil)
  (setq migemo-coding-system 'utf-8-unix)
  (load-library "migemo")
  (migemo-init)
#+END_SRC

* Mail/News/WWW
** APEL/FLIM/SEMI のインストール．
:PROPERTIES:
:var: src_dir=tnoda-src-dir elisp_dir=tnoda-elisp-dir emacs=emacs-app prefix=tnoda-dotfiles-dir
:END:
+ APEL
  #+BEGIN_SRC sh :tangle install-apel.sh
    cd $src_dir
    curl http://www.ring.gr.jp/archives/elisp/apel/apel-10.8.tar.gz | tar zxf -
    cd apel-10.8
    echo "(setq APEL_DIR \"${elisp_dir}/apel\")
    (setq EMU_DIR \"${elisp_dir}/emu\")" > APEL-CFG
    make EMACS=$emacs install
  #+END_SRC
  
+ FLIM
  #+BEGIN_SRC sh :tangle install-flim.sh
    cd src
    curl http://www.ring.gr.jp/archives/elisp/flim/flim-1.14/flim-1.14.9.tar.gz | tar zxf -
    cd flim-1.14.9
    echo "(add-to-list 'load-path \"${elisp_dir}/apel\")
    (add-to-list 'load-path \"${elisp_dir}/emu\")
    (require 'install)
    (defvar default-load-path load-path)
    (add-latest-path \"custom\")
    (add-path default-directory)
    (setq PREFIX \"${prefix}\")
    (setq FLIM_PREFIX \"flim\")
    (setq LISPDIR \"${elisp_dir}\")
    (setq FLIM_DIR (expand-file-name FLIM_PREFIX LISPDIR))
    (setq VERSION_SPECIFIC_LISPDIR \"${elisp_dir}\")" > FLIM-CFG
    make EMACS=$emacs install
  #+END_SRC

+ SEMI
  #+BEGIN_SRC sh :tangle install-semi.sh
    cd src
    curl http://www.ring.gr.jp/archives/elisp/semi/semi-1.14-for-flim-1.14/semi-1.14.6.tar.gz | tar zxf -
    cd semi-1.14.6
    echo "(add-to-list 'load-path \"${elisp_dir}/apel\")
    (add-to-list 'load-path \"${elisp_dir}/emu\")
    (add-to-list 'load-path \"${elisp_dir}/flim\")
    (add-to-list 'load-path (expand-file-name \".\"))
    (require 'install)
    (defvar default-load-path load-path)
    (add-latest-path \"custom\")
    (add-path default-directory)
    (add-path \"bitmap-mule\")
    (add-path \"flim\")
    (setq PREFIX \"${prefix}\")
    (setq LISPDIR \"${elisp_dir}\")
    (setq METHOD_DIR \"${prefix}/share/semi\")
    (setq SEMI_KERNEL_DIR \"${elisp_dir}/semi\")
    (setq SETUP_FILE_DIR SEMI_KERNEL_DIR)
    (setq METHOD_SRC_DIR \"methods\")
    (setq METHODS
        '(\"tm-au\" \"tm-file\" \"tm-html\" \"tm-image\" \"tm-mpeg\"
          \"tm-plain\" \"tm-ps\"
          \"tmdecode\"))" > SEMI-CFG
    make EMACS=$emacs install
  #+END_SRC

** Wanderlust                                                          :cvs:
+ インストール
  #+BEGIN_SRC sh :tangle install-wl.sh :var src_dir=tnoda-src-dir elisp_dir=tnoda-elisp-dir emacs=emacs-app info_dir=tnoda-info-dir prefix=tnoda-dotfiles-dir
    cd $src_dir
    expect -c "set timeout 10
    spawn cvs -d :pserver:anonymous@cvs.m17n.org:/cvs/root login
    expect \"CVS password:\" {
      send \"\n\"
    }
    "
    cvs -d :pserver:anonymous@cvs.m17n.org:/cvs/root checkout wanderlust
    cd wanderlust
    echo "(setq load-path (append
                     (list \"$elisp_dir/apel\"
                           \"$elisp_dir/emu\"
                           \"$elisp_dir/flim\"
                           \"$elisp_dir/semi\")
                     load-path))
    (setq wl-install-utils t)
    (setq wl-info-lang \"ja\")
    " > WL-CFG
    make EMACS=$emacs LISPDIR=$elisp_dir install PIXMAPDIR=$prefix/share/wl
    make EMACS=$emacs LISPDIR=$elisp_dir install PIXMAPDIR=$prefix/share/wl
    make EMACS=$emacs info
    make EMACS=$emacs INFODIR=$info_dir install-info
  #+END_SRC

+ 設定
  #+BEGIN_SRC emacs-lisp :tangle yes
    (autoload 'wl "wl" "Wanderlust" t)
    (autoload 'wl-other-frame "wl" "Wanderlust on new frame." t)
    (autoload 'wl-draft "wl-draft" "Write draft with Wanderlust." t)
  #+END_SRC

+ =.wl.el= の設定
  - =wl-init-hook= と =wl-exit-hook= で，ssh port forwarding を開始・終了する
    設定を追加している．

** emacs-w3m                                                           :cvs:
*** インストール
#+BEGIN_SRC sh :tangle install-emacs-w3m.sh :var src_dir=tnoda-src-dir prefx=tnoda-dotfiles-dir elisp_dir=tnoda-elisp-dir emacs=emacs-app info_dir=tnoda-info-dir
  cd $src_dir
  expect -c "set timeout 10
  spawn cvs -d :pserver:anonymous@cvs.namazu.org:/storage/cvsroot login
  expect \"CVS password:\" {
    send \"\n\"
  }
  "
  cvs -d :pserver:anonymous@cvs.namazu.org:/storage/cvsroot co emacs-w3m
  cd emacs-w3m
  autoconf
  ./configure --prefix=$prefix --with-lispdir=${elisp_dir}/emacs-w3m \
      --with-emacs=$emacs --with-icondir=${prefix}/share/emacs-w3m \
      --with-addpath=${elisp_dir}/apel:${elisp_dir}/emu:${elisp_dir}/flim \
      --infodir=$info_dir
  make
  make install-ja
  make install-icons
#+END_SRC

*** 行間を広くする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'w3m-load)
  (add-hook 'w3m-mode-hook 'tnoda/increase-line-spacing)
#+END_SRC

面倒なことは全て =~/.emacs-w3m.el= に書いてある．

** Mew
*** インストール
#+NAME: install-mew(prefix = tnoda-dotfiles-dir, elisp_dir = tnoda-elisp-dir, emacs = emacs-app)
#+BEGIN_SRC sh :tangle install-mew.sh
  cd src
  curl http://www.mew.org/Release/mew-6.5.tar.gz | tar zxf -
  cd mew-6.5
  autoconf
  ./configure --prefix=${prefix} \
          --with-elispdir=${elisp_dir}/mew \
          --with-emacs=$emacs --with-etcdir=${prefix}/share/mew
  make
  make install
  make install-info
  make install-jinfo
#+END_SRC

*** 最小限の設定

=mail-user-agent= は =simple.el= で，=define-mail-user-agent= は =subr.el= で，それぞれ定義されている．

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'mew)
  (require 'simple)
  (setq mail-user-agent 'mew-user-agent)
  (define-mail-user-agent
    'mew-user-agent
    'mew-user-agent-compose
    'mew-draft-send-message
    'mew-draft-kill
    'mew-send-hook)
#+END_SRC

*** 起動時にくるくる回らない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-demo nil)
#+END_SRC

*** 起動時にメールを取得しない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-auto-get nil)
#+END_SRC

*** 引用ラベルを簡潔にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-cite-fields '("From:"))
  (setq mew-cite-format "%s writes:\n")
#+END_SRC

*** Summary モードでは本文は不要なので，その分 subject を広くとる．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-summary-form '(type (5 date) " " (18 from) " " t (0 subj)))
#+END_SRC

*** 転送時に =Received:= と =Return-Path:= をヘッダから削る．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-field-delete-for-forwarding '("Received:" "Return-Path:"))
#+END_SRC

*** GnuPG を使う．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-prog-pgp "gpg")
#+END_SRC

*** 証明書の検証に失敗したり，証明書が無かったりする場合には SSL/TLS 接続しない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-ssl-verify-level 2)
#+END_SRC

*** 添付ファイルのデフォルトの保存先は =~/tmp=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-save-dir "~/tmp/")
#+END_SRC

*** 用事が済んだらすぐに SSH 接続を切る．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-ssh-keep-connection nil)
#+END_SRC

*** マスターパスワードを使う．PGP を使ってパスワードを保存．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-use-master-passwd t)
#+END_SRC

*** Hyper Estraier で検索する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mew-search-method 'est)
#+END_SRC

*** =draft= と =message= とでは行間を広く表示する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'mew-draft-mode-hook 'tnoda/increase-line-spacing)
  (add-hook 'mew-message-mode-hook 'tnoda/increase-line-spacing)
#+END_SRC

*** =draft-mode= で Org のテーブル記法と箇条書きを有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'mew-draft-mode-hook 'turn-on-orgstruct++)
  (add-hook 'mew-draft-mode-hook 'turn-on-orgtbl)
#+END_SRC

*** =.mew.el= の設定．
+ =mew-refile-guess-alist=
+ =mew-config-alist=

*** test/html を =message= バッファに表示する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'mew-w3m)
  (setq mew-use-text/html t)
#+END_SRC

* Lang
** Clojure                                                       :marmalade:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (package-install 'slime)
  (package-install 'slime-repl)
#+END_SRC

=package-install= すると，  =(require 'clojure-mode)= しなくてもいいみたい．

*** Install clojure-mode using el-get.                              :elget:
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync '(clojure-mode))
  (require 'clojure-mode)
#+END_SRC

*** Disable =C-c t= of =clojure-mode-map=.                            :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key clojure-mode-map (kbd "C-c t") nil)
#+END_SRC

*** =clojure-mode= は =<f5>= で =clojure-jack-in=.              :key:command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/clojure-mode-f5-key ()
    (define-key clojure-mode-map (kbd "<f5>") 'clojure-jack-in))
  
  (add-hook 'clojure-mode-hook 'tnoda/clojure-mode-f5-key)
#+END_SRC

*** =clojure-jack-in= で =lein2= を使う．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq clojure-swank-command
        (concat (expand-file-name "~/.lein/lein2") " jack-in %s"))
#+END_SRC

*** Leiningen utility functions.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/lein-root (&optional dir)
    (interactive)
    (setq dir (or dir default-directory))
    (if (file-exists-p (expand-file-name "project.clj" dir))
        (expand-file-name dir)
      (let ((new-dir (expand-file-name (file-name-as-directory "..") dir)))
        (unless (string-match "\\(^[[:alpha:]]:/$\\|^/[^\/]+:/?$\\|^/$\\)" dir)
          (tnoda/lein-root new-dir)))))
  
  (defun tnoda/lein-guess-namespace ()
    "Return the clojure namespace assiatted with the current buffer."
    (interactive)
    (replace-regexp-in-string "_" "-" (replace-regexp-in-string "/" "." (substring (file-name-sans-extension buffer-file-name)
                                                                                   (+ 4 (length (tnoda/lein-root)))))))
#+END_SRC

*** =M-x run-lisp= で Clojure の REPL.                              :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq inferior-lisp-program (expand-file-name "~/.lein/lein2 repl"))
#+END_SRC

*** paredit
**** =clojure-mode= で paredit を有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'clojure-mode-hook 'enable-paredit-mode)
#+END_SRC

**** =slime-repl-mode= と =inferior-lisp-mode= とで paredit に =[]= と ={}= も括弧扱いさせる．
via http://stackoverflow.com/questions/8598116/paredit-curly-brace-matching-in-swank-clojure-repl

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/setup-slime-repl-paredit ()
    (define-key slime-repl-mode-map
      (kbd "DEL") 'paredit-backward-delete)
    (define-key slime-repl-mode-map
      (kbd "{") 'paredit-open-curly)
    (define-key slime-repl-mode-map
      (kbd "}") 'paredit-close-curly)
    (modify-syntax-entry ?\{ "(}")
    (modify-syntax-entry ?\} "){")
    (modify-syntax-entry ?\[ "(]")
    (modify-syntax-entry ?\] ")[")
    (modify-syntax-entry ?~ "'   ")
    (modify-syntax-entry ?, "    ")
    (modify-syntax-entry ?^ "'")
    (modify-syntax-entry ?= "'"))
  
  (add-hook 'slime-repl-mode-hook 'tnoda/setup-slime-repl-paredit)
  (add-hook 'slime-repl-mode-hook 'enable-paredit-mode)
  (add-hook 'inferior-lisp-mode-hook 'enable-paredit-mode)
#+END_SRC


*** Rainbow Delimiters
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'slime-repl-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

*** Syntax highlighting in repl buffers
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/clojure-mode-slime-font-lock-setup ()
    (let (font-lock-mode)
      (clojure-mode-font-lock-setup)))
  (add-hook 'slime-repl-mode-hook 'tnoda/clojure-mode-slime-font-lock-setup)
#+END_SRC

*** Enable eldoc in slime-repl-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'slime-repl-mode-hook 'clojure-localize-documentation-function)
  (add-hook 'slime-repl-mode-hook 'turn-on-eldoc-mode)
#+END_SRC

** CoffeeScript                                                  :marmalade:
+ インストール
  #+BEGIN_SRC emacs-lisp :tangle install.el
    (package-install 'coffee-mode)
    (package-install 'flymake-coffee)
  #+END_SRC

+ =coffee-mode= で flymake を有効にする．
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-hook 'coffee-mode-hook 'flymake-coffee-load)
  #+END_SRC
  
** Ruby
*** インストール
+ =ruby-mode.el= などは GitHub から最新ものを入手したい．
  #+BEGIN_SRC emacs-lisp :tangle install.el
    (package-install 'ruby-mode)
    (package-install 'ruby-electric)
    (package-install 'inf-ruby)
    (package-install 'ruby-compilation)
    (auto-install-from-url "https://raw.github.com/ruby/ruby/trunk/misc/ruby-style.el")
    (auto-install-from-url "https://raw.github.com/ruby/ruby/trunk/misc/rdoc-mode.el")
    (package-install 'yari)
    (package-install 'flymake-ruby)
    (auto-install-from-emacswiki "ruby-block.el")
  #+END_SRC

*** =autoload= ではなく =require= する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'ruby-mode)
  (require 'inf-ruby)
  (require 'ruby-electric)
  (require 'ruby-style)
  (require 'ruby-compilation)
#+END_SRC

*** =~/.rbenv/shims= を =exec-path= に追加する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'exec-path (expand-file-name "~/.rbenv/shims"))
#+END_SRC

*** 拡張子への関連づけ (=.rb .rake .gemspec .ru Rakefile Gemfile ... ==).
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.rake$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.gemspec$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.ru$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Gemfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Capfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Vagrantfile$" . ruby-mode))
#+END_SRC

*** Ruby-mode を =interpreter-mode-alist= に追加する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'interpreter-mode-alist '("ruby" . ruby-mode))
#+END_SRC

*** スタイルの設定．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ruby-use-encoding-map nil)
  (setq ruby-deep-indent-paren-style nil)
  (setq ruby-insert-encoding-magic-comment nil)
#+END_SRC

*** =C-m= を =reindent-then-newline-and-indent= に設定．              :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key ruby-mode-map (kbd "RET") 'reindent-then-newline-and-indent)
#+END_SRC

*** =ruby-mode= の =C-M-a= で =tnoda/ruby-beginning-of-defun=.        :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/ruby-beginning-of-defun ()
    "Move backward to the beginning of the current defun"
    (interactive)
    (and (re-search-backward "\\bdef\\b" nil t)
         (beginning-of-line)))
  
  (define-key ruby-mode-map (kbd "C-M-a") 'tnoda/ruby-beginning-of-defun)
#+END_SRC

*** =ruby-mode= の =C-M-e= で =tnoda/ruby-end-of-defun=.              :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/ruby-beginning-of-defun-indent-level ()
    (save-excursion
      (end-of-line)
      (when (re-search-backward "^\\( *\\)def\\b" nil t)
        (length (match-string 1)))))
  
  (defun tnoda/ruby-end-of-defun ()
    "Move forward to the end of the current defun"
    (interactive)
    (let ((current-indent-level (tnoda/ruby-beginning-of-defun-indent-level)))
      (and current-indent-level
           (re-search-forward (concat "^"
                                      (make-string current-indent-level 32)
                                      "end\\b")
                              nil t)
           (forward-line 1))))
  
  (define-key ruby-mode-map (kbd "C-M-e") 'tnoda/ruby-end-of-defun)
#+END_SRC

*** =ruby-mode= の =C-M-h= で =tnoda/ruby-mark-defun=.                :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/ruby-mark-defun ()
    "Put mark at the end of the current defun, point at the beginning"
    (interactive)
    (flet ((ruby-beginning-of-defun (&optional arg) (tnoda/ruby-beginning-of-defun))
           (ruby-end-of-defun (&optional arg) (tnoda/ruby-end-of-defun)))
      (call-interactively 'ruby-mark-defun)))
  
  (define-key ruby-mode-map (kbd "C-M-h") 'tnoda/ruby-mark-defun)
#+END_SRC

*** =ruby-electric= を有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/ruby-electric-activate ()
     (ruby-electric-mode t))
  (add-hook 'ruby-mode-hook 'tnoda/ruby-electric-activate)
#+END_SRC

*** flymake-ruby を使う．

flymake-ruby で使う Ruby は rbenv のもの．

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq flymake-ruby-executable "~/.rbenv/shims/ruby")
  (add-hook 'ruby-mode-hook 'flymake-ruby-load)
#+END_SRC

*** =ruby-mode-map= で =TAB= を =ruby-indent-command= に割り当てているので yasnippet と競合するのを回避する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (yas/advise-indent-function 'ruby-indent-line)
#+END_SRC

*** =align-rules-list=. =M-x align= でコンマ区切りとハッシュを整列． :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'align)
  (add-to-list 'align-rules-list
               '(ruby-comma-delimiter
                 (regexp . ",\\(\\s-*\\)[^# \t\n]")
                 (repeat . t)
                 (modes  . '(ruby-mode))))
  (add-to-list 'align-rules-list
               '(ruby-hash-literal
                 (regexp . "\\(\\s-*\\)=>\\s-*[^# \t\n]")
                 (repeat . t)
                 (modes  . '(ruby-mode))))
#+END_SRC

*** =.rdoc= なファイルを =rdoc-mode= で開く．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'rdoc-mode)
  (add-to-list 'auto-mode-alist '("\\.rdoc$" . rdoc-mode))
#+END_SRC

*** =ruby-mode= の =C-c C-c= で =ruby-compilation-this-buffer=.       :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key ruby-mode-map (kbd "C-c C-c") 'ruby-compilation-this-buffer)
#+END_SRC

*** =ruby-block.el=
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'ruby-block)
  (ruby-block-mode t)
  (setq ruby-block-highlight-toggle 't)
#+END_SRC

*** =hideshow-org= を有効にする．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'ruby-mode-hook 'tnoda/hs-org/minor-mode-activate)
  (add-to-list 'hs-special-modes-alist
               (list 'ruby-mode
                     ruby-electric-simple-keywords-re
                     "end"
                     "#"
                     'ruby-forward-sexp
                     nil))
#+END_SRC

** Rinari
*** COMMENT インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (package-install 'rinari)
#+END_SRC

*** Install via el-get                                              :elget:
#+BEGIN_SRC emacs-lisp :tangle yes
  (el-get 'sync '(rinari))
  (el-get 'sync '(rspec-mode))
#+END_SRC

*** Fix rinari-root
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'rinari)
  (defun tnoda/rinari-root (&optional dir home)
    "Return the Rails root directory."
    (or dir (setq dir default-directory))
    (if (file-exists-p (expand-file-name
                        "rails" (expand-file-name "script" dir)))
        dir
      (let ((new-dir (expand-file-name (file-name-as-directory "..") dir)))
        ;; regexp to match windows roots, tramp roots, or regular posix roots
        (unless (string-match "\\(^[[:alpha:]]:/$\\|^/[^\/]+:/?$\\|^/$\\)" dir)
          (rinari-root new-dir)))))
  (fset 'rinari-root 'tnoda/rinari-root)
#+END_SRC

*** =s-s= で Spork サーバを起動・停止する．                   :key:command:

+ =tnoda/spork-start= コマンドで起動する．
+ =tnoda/spork-stop= コマンドで停止する．

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar tnoda/spork-start-p nil)
  
  (defun tnoda/spork-start ()
    "Start the Spork server."
    (interactive)
    (setq tnoda/spork-command (format "cd %s && bundle exec spork testunit" (rinari-root)))
    (setq tnoda/spork-process (start-process-shell-command "spork-server" "*spork*"
                                                           tnoda/spork-command))
    (set-process-sentinel tnoda/spork-process
                          (lambda (proc msg) (message "%s %s" proc msg)))
    (setq tnoda/spork-start-p t))
  
  (defun tnoda/spork-stop ()
    "Stop the Spork server."
    (interactive)
    (setq tnoda/spork-start-p nil)
    (kill-buffer "*spork*")
    (interrupt-process tnoda/spork-process))
  
  (defun tnoda/spork-toggle ()
    "Start and stop the Spork server."
    (interactive)
    (if tnoda/spork-start-p
        (tnoda/spork-stop)
      (tnoda/spork-start)))
  
  (global-set-key (kbd "s-s") 'tnoda/spork-toggle)
#+END_SRC

*** =rinari-test= で Spork-testunit の =testdrb= を使う．

このとき，=*spork*= バッファが無ければ =tnoda/spork-start= で Spork サーバを起動する．

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/rinari-test ()
    "Test the current function using Spork-testunit."
    (interactive)
    (when (not (get-buffer "*spork*"))
      (tnoda/spork-start)
      (sit-for 5))
    (let ((ruby-compilation-executable "testdrb"))
      (call-interactively 'rinari-test)))
#+END_SRC

*** =rinari-minor-mode= の =C-c ; t= を =tnoda/rinari-test= に置き換える． :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key rinari-minor-mode-map (kbd "C-c ; t") 'tnoda/rinari-test)
#+END_SRC

*** =TAGS= ファイルを作るコマンド =tnoda/rinari-tags-update=.       :command:

=rinari-minor-mode= 開始時に TAGS ファイルを更新する．

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/rinari-tags-command ()
    "Return a command to update the TAGS file."
    (format "cd %s && etags -a -o TAGS app/**/*.rb lib/**/*.rb"
            (rinari-root)))
  
  (defun tnoda/rinari-tags-update ()
    "Update the TAGS file asynchronously."
    (interactive)
    (let ((etags-process (start-process-shell-command "etags" "*etags*"
                                                      (tnoda/rinari-tags-command))))
      (message "Updating the TAGS file ...")
      (set-process-sentinel etags-process
                            (lambda (proc msg)
                              (cond ((equal "finished\n" msg)
                                     (message "done."))
                                    (t
                                     (message "%s %s" proc msg)))))))
  
  (add-to-list 'rinari-minor-mode-hook 'tnoda/rinari-tags-update)
#+END_SRC

*** =rinari-minor-mode= の =C-c ; T= に =tnoda/rinari-tags-update= を割り当てる． :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key rinari-minor-mode-map (kbd "C-c ; T") 'tnoda/rinari-tags-update)
#+END_SRC

** rcodetools
*** インストール
#+BEGIN_SRC sh :tangle install-rcodetools.sh :var elisp_dir=tnoda-elisp-dir emacs=emacs-app
  gem install rcodetools
  for el in `gem content rcodetools | grep \.el$`
  do
      cp $el $elisp_dir
      cd $elisp_dir
      $emacs -batch -f batch-byte-compile *rcodetools.el
  done
#+END_SRC

*** =ruby-mode= で =rcodetools.el= のコマンドを使えるようにする．       :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'rcodetools)
  (define-key ruby-mode-map (kbd "M-C-i") 'rct-complete-symbol)
  (define-key ruby-mode-map (kbd "S-<f5>") 'xmp)
  (define-key ruby-mode-map (kbd "C-c C-t") 'ruby-toggle-buffer)
#+END_SRC

*** =anything-rcodetools.el= で =ri-ruby.el= の代わりに =yari= を使う．
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'anything-rcodetools)
  (setq rct-get-all-methods-command "PAGER=cat fri -l")
  
  (defun tnoda/anything-rct-ri (meth)
    (yari (get-text-property 0 'desc meth)))
  
  (fset 'anything-rct-ri 'tnoda/anything-rct-ri)
#+END_SRC

** Markdown                                                    :autoinstall:
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-url "http://jblevins.org/git/markdown-mode.git/plain/markdown-mode.el")
#+END_SRC

*** Require
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'markdown-mode)
#+END_SRC

*** =.text= なファイルは =markdown-mode= で開く．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.text" . markdown-mode))
#+END_SRC

*** =.md= なファイルは =gfm-mode= で開く．

=gfm-mode= なファイルには，特製の =bin/gfm= を使う．

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.md" . gfm-mode))
  (defun tnoda/gfm-custom ()
    "gfm-mode-hook"
    (setq markdown-command (expand-file-name "gfm" tnoda/bin-dir)))
  (add-hook 'gfm-mode-hook 'tnoda/gfm-custom)
#+END_SRC

*** =<S-tab>= で =markdown-shifttab=.                                   :key:

デフォルトでは =markdown-shifttab= が =<S-iso-lefttab>= に割り当てられ
ているため．

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/markdown-shifttab-fix ()
    "Bind `markdown-shifttab' to <S-tab>"
    (local-set-key (kbd "<S-tab>") 'markdown-shifttab))
  
  (add-hook 'markdown-mode-hook 'tnoda/markdown-shifttab-fix)
  (add-hook 'gfm-mode-hook 'tnoda/markdown-shifttab-fix)
#+END_SRC

** Zencoding                                                           :git:
+ https://github.com/rooney/zencoding を submodule にして使う．
+ HTML モードで使う

#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'load-path (expand-file-name "zencoding" tnoda/dotfiles-dir))
  (require 'zencoding-mode)
  (add-hook 'html-mode-hook 'zencoding-mode)
#+END_SRC

** C/C++

そういえば最近 Ruby の拡張モジュール以外書いていない．

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'ruby-style) ; Documentation-purposes only: actually loaded in the Ruby section.
  (add-hook 'c-mode-hook 'ruby-style-c-mode)  
  (add-hook 'c++-mode-hook 'ruby-style-c-mode)
#+END_SRC

** Haskell
*** =$HOME/Library/Haskell/bin= と =$HOME/.cabal/bin= とを =exec-path= に追加．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'exec-path (expand-file-name "~/Library/Haskell/bin"))
  (add-to-list 'exec-path (expand-file-name "~/.cabal/bin"))
#+END_SRC

*** haskell-mode のインストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (package-install 'haskell-mode)
#+END_SRC

*** ghc-mod インストール
+ 事前に Cabal でインストール．
  - ghc-mod
  - hlint
+ =ghc*.el= のコンパイルとインストール
  #+BEGIN_SRC sh :tangle install-ghc-mod.sh :var emacs=emacs-app elisp_dir=tnoda-elisp-dir
    cabal update
    cabal install ghc-mod
    cabal install hlint
    make -C ~/Library/Haskell/ghc-7.4.2/lib/ghc-mod-1.11.2/share EMACS=$emacs
    mkdir -p $elisp_dir/ghc-mod
    cp ~/Library/Haskell/ghc-7.4.2/lib/ghc-mod-1.11.2/share/*.elc $elisp_dir/ghc-mod
  #+END_SRC

*** flymake を有効に
#+BEGIN_SRC emacs-lisp :tangle yes
    (autoload 'ghc-init "ghc" nil t)
    (add-hook 'haskell-mode-hook (lambda () (ghc-init) (flymake-mode)))
#+END_SRC

* ESS で R を使う．
** インストール                                                        :svn:
#+BEGIN_SRC sh :tangle install-ess.sh :var src_dir=tnoda-src-dir elisp_dir=tnoda-elisp-dir info_dir=tnoda-info-dir prefix=tnoda-dotfiles-dir emacs=emacs-app
  cd $src_dir
  svn checkout https://svn.r-project.org/ESS/trunk ess
  cd $src_dir/ess
  make -C lisp EMACS=$emacs LISPDIR=$elisp_dir/ess INFODIR=$info_dir ETCDIR=$elisp_dir/ess/etc install
  make -C doc EMACS=$emacs LISPDIR=$elisp_dir/ess INFODIR=$info_dir ETCDIR=$elisp_dir/ess/etc install-info
  make -C etc EMACS=$emacs LISPDIR=$elisp_dir/ess INFODIR=$info_dir ETCDIR=$elisp_dir/ess/etc install
#+END_SRC

** =M-x R RET= で ESS (R) 開始．                                   :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'ess-site)
#+END_SRC

* Twitter                                                     :git:rubikitch:

twittering-mode.el を使う．

** インストール

https://github.com/hayamiz/twittering-mode を submodule に．

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path (expand-file-name "twittering-mode" tnoda/src-dir))
#+END_SRC

** =M-x twit= で =twittering-mode=.                                 :command:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'twittering-mode)
#+END_SRC

** 各 tweet 一行で表示．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq twittering-status-format
        "%C{%Y-%m-%d %H:%M:%S} %s > %T // from %f%L%r%R")
#+END_SRC

** 認証済み OAuth トークンを PGP で暗号化して保存．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq twittering-use-master-password t)
#+END_SRC

* Network
** =s-p= でプロキシサーバへの SSH フォワーディング開始・停止．         :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (load "~/.ssh-proxy.el")
#+END_SRC

* Anything
** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-batch "anything")
#+END_SRC

** Anything で使うプレフィクスキーを =M-@= にする．                     :key:

+ anything-config.el で設定されるデフォルトは =<f5> a= だが，
  =<f5>= を =tnoda/compile-or-executable-interpret= に割り当てているため，
  =(require 'anything-startup)= でエラーになる．
+ =M-@= はデフォルトでは =mark-word= に割り当てられてる．しかし，
  sense-region.el の導入により =C-SPC= 連打で =mark-word=
  できるようになったので，Anything で有り難く使う．

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq anything-command-map-prefix-key "M-@")
  (require 'anything-startup)
#+END_SRC

** Anything が =ctl-x-map= を上書きする？ので再度 =C-x C-j= を =skk-mode= に． :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key ctl-x-map (kbd "C-j") 'skk-mode)
#+END_SRC

** ido と喧嘩させない．
#+BEGIN_SRC emacs-lisp :tangle yes
  (anything-read-string-mode 0)
#+END_SRC

** デフォルト設定が遅い．
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq anything-input-idle-delay 0.03)
#+END_SRC

** =C-x b= を =anything-for-files= に．                                :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key ctl-x-map (kbd "b") 'anything-for-files)
#+END_SRC

** =M-!=, =M-|= で =C-o= を押すとシェルコマンド履歴から補完する．      :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (anything-complete-shell-history-setup-key (kbd "C-o"))
#+END_SRC

** =M-y= を anything-show-kill-ring に．キルリングの補完と絞り込み．   :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-y") 'anything-show-kill-ring)
#+END_SRC

** anything-c-moccur.el

color-moccur.el に依存している．

*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-url "http://svn.coderepos.org/share/lang/elisp/anything-c-moccur/trunk/anything-c-moccur.el")
#+END_SRC

*** =C-c o= で =anything-c-moccur-occur-by-moccur=.                     :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'anything-c-moccur)
  (global-set-key (kbd "C-c o") 'anything-c-moccur-occur-by-moccur)
#+END_SRC

*** isearch 中に =M-o= で anything-c-moccur に移行．                    :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key isearch-mode-map (kbd "M-o") 'anything-c-moccur-from-isearch)
#+END_SRC

** anything-project.el
*** インストール
#+BEGIN_SRC emacs-lisp :tangle install.el
  (auto-install-from-url "https://raw.github.com/imakado/anything-project/master/anything-project.el")
#+END_SRC

*** =C-c f= で =anything-project=.                                      :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'anything-project)
  (global-set-key (kbd "C-c f") 'anything-project)
#+END_SRC

** =ruby-mode= の =C-c C-y= で =yari-anything=.                         :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun tnoda/ri-bind-key ()
    (local-set-key (kbd "C-c C-y") 'yari-anything))
  
  (add-hook 'ruby-mode-hook 'tnoda/ri-bind-key)
#+END_SRC

* SDIC
** インストール
#+BEGIN_SRC sh :tangle install-sdic.sh :var src_dir=tnoda-src-dir elisp_dir=tnoda-elisp-dir emacs=emacs-app info_dir=tnoda-info-dir prefix=tnoda-dotfiles-dir
  cd $src_dir
  curl http://www.namazu.org/~tsuchiya/sdic/sdic-2.1.3.tar.gz | tar zxf -
  cd sdic-2.1.3
  curl -O http://www.namazu.org/~tsuchiya/sdic/data/gene95.tar.gz
  curl -O http://www.namazu.org/~tsuchiya/sdic/data/edict.gz
  ./configure --prefix=$prefix --infodir=$info_dir --with-emacs=$emacs  --with-lispdir=$elisp_dir --with-dictdir=$prefix/share/dict
  make install
  make install-info
  make dict
  make install-dict
#+END_SRC

** =C-c w= で SDIC 辞書検索．                                          :key:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'sdic)
  (global-set-key (kbd "C-c w") 'sdic-describe-word-at-point)
#+END_SRC

** popwin を使って，SDIC の検索結果を下に表示する．
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'special-display-buffer-names "*sdic*")
  (push '("*sdic*" :position bottom) popwin:special-display-config)
#+END_SRC
